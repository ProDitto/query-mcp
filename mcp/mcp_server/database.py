import psycopg2
from psycopg2 import OperationalError, DatabaseError
from datetime import date
import random


class DatabaseManager:
    """
    A class to manage interactions with a PostgreSQL database for package vulnerability tracking.
    Handles base images, packages, tags, vulnerabilities, and their relationships.
    """

    def __init__(self, db_name, user, password, host="localhost", port=5432):
        """
        Initializes the DatabaseManager for package vulnerability tracking.
        :param db_name: The name of the PostgreSQL database.
        :param user: The PostgreSQL username.
        :param password: The PostgreSQL password.
        :param host: The database host address (defaults to localhost).
        :param port: The connection port number (defaults to 5432).
        """
        self.db_name = db_name
        self.user = user
        self.password = password
        self.host = host
        self.port = port
        self.conn = None
        self.cursor = None
        self._connect()
    
    def get_name(self):
        return f"{self.db_name} {self.host} {self.port}"

    def _connect(self):
        """
        Establishes a connection to the PostgreSQL database.
        """
        try:
            self.conn = psycopg2.connect(
                dbname=self.db_name,
                user=self.user,
                password=self.password,
                host=self.host,
                port=self.port
            )
            self.cursor = self.conn.cursor()
            print(f"Connected to PostgreSQL database: {self.db_name}")
        except OperationalError as e:
            print(f"Error connecting to PostgreSQL database: {e}")

    def close_connection(self):
        """
        Closes the database connection.
        Commits any pending changes before closing.
        """
        if self.conn:
            self.conn.commit()
            self.conn.close()
            print("PostgreSQL database connection closed.")

    def reset_database(self):
        """
        Resets the database by dropping and recreating it.
        """
        # self.close_connection()  # Close the existing connection
        
        try:
            temp_conn = psycopg2.connect(user=self.user, password=self.password, 
                                        host=self.host, port=self.port, dbname="postgres")
            temp_conn.autocommit = True
            temp_cursor = temp_conn.cursor()
            
            terminate_connections_sql = f"""
            SELECT pg_terminate_backend(pg_stat_activity.pid)
            FROM pg_stat_activity
            WHERE pg_stat_activity.datname = '{self.db_name}';
            """
            temp_cursor.execute(terminate_connections_sql)

            drop_db_sql = f"DROP DATABASE IF EXISTS {self.db_name};"
            temp_cursor.execute(drop_db_sql)
            print(f"Database '{self.db_name}' dropped.")
            
            create_db_sql = f"CREATE DATABASE {self.db_name};"
            temp_cursor.execute(create_db_sql)
            print(f"Database '{self.db_name}' created.")

        except (OperationalError, DatabaseError) as e:
            print(f"Error during database reset: {e}")
        finally:
            if temp_conn:
                temp_cursor.close()
                temp_conn.close()

        self._connect()  # Reconnect to the newly created database

    def setup_database(self):
        """
        Sets up the package vulnerability tracking database schema.
        """
        schema_sql = """
        -- 1. Base Images
        CREATE TABLE base_images (
            id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            version VARCHAR(100) NOT NULL,
            release_date DATE
        );

        -- 2. Packages
        CREATE TABLE packages (
            id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            base_image_id INT NOT NULL
                REFERENCES base_images(id) ON DELETE CASCADE
        );

        -- 3. Package Tags
        CREATE TABLE package_tags (
            id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            package_id INT NOT NULL
                REFERENCES packages(id) ON DELETE CASCADE,
            tag VARCHAR(100) NOT NULL,
            created_at TIMESTAMPTZ DEFAULT NOW()
        );

        -- 4. Vulnerabilities
        CREATE TABLE vulnerabilities (
            id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            cve_id VARCHAR(50) UNIQUE NOT NULL,
            description TEXT,
            discovered_at DATE
        );

        -- 5. Tagâ€“Vulnerability Relationship
        CREATE TABLE tag_vulnerabilities (
            package_tag_id INT NOT NULL
                REFERENCES package_tags(id) ON DELETE CASCADE,
            vulnerability_id INT NOT NULL
                REFERENCES vulnerabilities(id) ON DELETE CASCADE,
            severity VARCHAR(50),
            PRIMARY KEY (package_tag_id, vulnerability_id)
        );

        -- 6. Commits
        CREATE TABLE commits (
            id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            package_tag_id INT NOT NULL
                REFERENCES package_tags(id) ON DELETE CASCADE,
            commit_hash VARCHAR(100) UNIQUE NOT NULL,
            author VARCHAR(255),
            committed_at TIMESTAMPTZ DEFAULT NOW(),
            message TEXT
        );

        -- Indexes for performance
        CREATE INDEX idx_packages_base_image ON packages(base_image_id);
        CREATE INDEX idx_tags_package_id ON package_tags(package_id);
        CREATE INDEX idx_tag_vuln_vulnerability_id ON tag_vulnerabilities(vulnerability_id);
        CREATE INDEX idx_commits_package_tag_id ON commits(package_tag_id);
        """
        
        try:
            if self.cursor:
                self.cursor.execute(schema_sql)
                self.conn.commit()
                print("Package vulnerability tracking schema created successfully.")
        except DatabaseError as e:
            print(f"Error setting up database schema: {e}")
            self.conn.rollback()
        return self._seed_db()

    # CRUD operations for base_images
    def create_base_image(self, name, version, release_date=None):
        """
        Creates a new base image entry.
        :param name: Base image name
        :param version: Version of the base image
        :param release_date: Optional release date (defaults to None)
        """
        sql = "INSERT INTO base_images (name, version, release_date) VALUES (%s, %s, %s) RETURNING id;"
        try:
            self.cursor.execute(sql, (name, version, release_date))
            new_id = self.cursor.fetchone()[0]
            self.conn.commit()
            print(f"Created base image {name}:{version} with ID {new_id}")
            return new_id
        except DatabaseError as e:
            print(f"Error creating base image: {e}")
            self.conn.rollback()
            return None

    def get_base_images(self, name_filter=None, version_filter=None):
        """
        Retrieves base images, optionally filtered by name or version.
        :param name_filter: Optional name filter (partial match)
        :param version_filter: Optional version filter (partial match)
        """
        sql = "SELECT * FROM base_images WHERE TRUE"
        params = []
        
        if name_filter:
            sql += " AND name ILIKE %s"
            params.append(f"%{name_filter}%")
        if version_filter:
            sql += " AND version ILIKE %s"
            params.append(f"%{version_filter}%")
            
        try:
            self.cursor.execute(sql, params)
            return self.cursor.fetchall()
        except DatabaseError as e:
            print(f"Error retrieving base images: {e}")
            return []

    # CRUD operations for packages
    def create_package(self, name, base_image_id):
        """
        Creates a new package associated with a base image.
        :param name: Package name
        :param base_image_id: ID of the associated base image
        """
        sql = "INSERT INTO packages (name, base_image_id) VALUES (%s, %s) RETURNING id;"
        try:
            self.cursor.execute(sql, (name, base_image_id))
            new_id = self.cursor.fetchone()[0]
            self.conn.commit()
            print(f"Created package {name} with ID {new_id}")
            return new_id
        except DatabaseError as e:
            print(f"Error creating package: {e}")
            self.conn.rollback()
            return None

    def get_packages_for_base_image(self, base_image_id):
        """
        Retrieves all packages for a specific base image.
        :param base_image_id: ID of the base image
        """
        sql = "SELECT * FROM packages WHERE base_image_id = %s;"
        try:
            self.cursor.execute(sql, (base_image_id,))
            return self.cursor.fetchall()
        except DatabaseError as e:
            print(f"Error retrieving packages: {e}")
            return []

    # CRUD operations for package_tags
    def create_package_tag(self, package_id, tag):
        """
        Creates a new tag for a package.
        :param package_id: ID of the package
        :param tag: Tag name/version
        """
        sql = "INSERT INTO package_tags (package_id, tag) VALUES (%s, %s) RETURNING id;"
        try:
            self.cursor.execute(sql, (package_id, tag))
            new_id = self.cursor.fetchone()[0]
            self.conn.commit()
            print(f"Created tag {tag} for package ID {package_id}")
            return new_id
        except DatabaseError as e:
            print(f"Error creating package tag: {e}")
            self.conn.rollback()
            return None

    def get_tags_for_package(self, package_id):
        """
        Retrieves all tags for a specific package.
        :param package_id: ID of the package
        """
        sql = "SELECT * FROM package_tags WHERE package_id = %s;"
        try:
            self.cursor.execute(sql, (package_id,))
            return self.cursor.fetchall()
        except DatabaseError as e:
            print(f"Error retrieving package tags: {e}")
            return []

    # CRUD operations for vulnerabilities
    def create_vulnerability(self, cve_id, description=None, discovered_at=None):
        """
        Creates a new vulnerability record.
        :param cve_id: CVE identifier (e.g., "CVE-2023-1234")
        :param description: Optional description of the vulnerability
        :param discovered_at: Optional date the vulnerability was discovered
        """
        sql = "INSERT INTO vulnerabilities (cve_id, description, discovered_at) VALUES (%s, %s, %s) RETURNING id;"
        try:
            self.cursor.execute(sql, (cve_id, description, discovered_at))
            new_id = self.cursor.fetchone()[0]
            self.conn.commit()
            print(f"Created vulnerability {cve_id} with ID {new_id}")
            return new_id
        except DatabaseError as e:
            print(f"Error creating vulnerability: {e}")
            self.conn.rollback()
            return None

    def get_vulnerability_by_cve(self, cve_id):
        """
        Retrieves a vulnerability by its CVE ID.
        :param cve_id: CVE identifier (e.g., "CVE-2023-1234")
        """
        sql = "SELECT * FROM vulnerabilities WHERE cve_id = %s;"
        try:
            self.cursor.execute(sql, (cve_id,))
            return self.cursor.fetchone()
        except DatabaseError as e:
            print(f"Error retrieving vulnerability: {e}")
            return None

    # Operations for tag_vulnerabilities (many-to-many relationship)
    def add_vulnerability_to_tag(self, package_tag_id, vulnerability_id, severity=None):
        """
        Associates a vulnerability with a package tag.
        :param package_tag_id: ID of the package tag
        :param vulnerability_id: ID of the vulnerability
        :param severity: Optional severity level
        """
        sql = """
        INSERT INTO tag_vulnerabilities (package_tag_id, vulnerability_id, severity) 
        VALUES (%s, %s, %s)
        ON CONFLICT (package_tag_id, vulnerability_id) 
        DO UPDATE SET severity = EXCLUDED.severity;
        """
        try:
            self.cursor.execute(sql, (package_tag_id, vulnerability_id, severity))
            self.conn.commit()
            print(f"Associated vulnerability {vulnerability_id} with tag {package_tag_id}")
            return True
        except DatabaseError as e:
            print(f"Error adding vulnerability to tag: {e}")
            self.conn.rollback()
            return False

    def get_vulnerabilities_for_tag(self, package_tag_id):
        """
        Retrieves all vulnerabilities associated with a package tag.
        :param package_tag_id: ID of the package tag
        """
        sql = """
        SELECT v.*, tv.severity 
        FROM vulnerabilities v
        JOIN tag_vulnerabilities tv ON v.id = tv.vulnerability_id
        WHERE tv.package_tag_id = %s;
        """
        try:
            self.cursor.execute(sql, (package_tag_id,))
            return self.cursor.fetchall()
        except DatabaseError as e:
            print(f"Error retrieving tag vulnerabilities: {e}")
            return []

    # CRUD operations for commits
    def create_commit(self, package_tag_id, commit_hash, author=None, message=None):
        """
        Creates a new commit record associated with a package tag.
        :param package_tag_id: ID of the package tag
        :param commit_hash: Git commit hash
        :param author: Optional author name
        :param message: Optional commit message
        """
        sql = """
        INSERT INTO commits (package_tag_id, commit_hash, author, message) 
        VALUES (%s, %s, %s, %s) RETURNING id;
        """
        try:
            self.cursor.execute(sql, (package_tag_id, commit_hash, author, message))
            new_id = self.cursor.fetchone()[0]
            self.conn.commit()
            print(f"Created commit {commit_hash} for tag ID {package_tag_id}")
            return new_id
        except DatabaseError as e:
            print(f"Error creating commit: {e}")
            self.conn.rollback()
            return None

    def get_commits_for_tag(self, package_tag_id):
        """
        Retrieves all commits associated with a package tag.
        :param package_tag_id: ID of the package tag
        """
        sql = "SELECT * FROM commits WHERE package_tag_id = %s ORDER BY committed_at DESC;"
        try:
            self.cursor.execute(sql, (package_tag_id,))
            return self.cursor.fetchall()
        except DatabaseError as e:
            print(f"Error retrieving commits: {e}")
            return []
    
    def _seed_db(self):
        """Seed all database tables with sample data."""
        try:
            # 1. Seed base_images (10+ entries)
            base_images = [
                ("ubuntu", "20.04", date(2020, 4, 23)),
                ("ubuntu", "22.04", date(2022, 4, 21)),
                ("debian", "10", date(2019, 7, 6)),
                ("debian", "11", date(2021, 8, 14)),
                ("alpine", "3.16", date(2022, 5, 23)),
                ("alpine", "3.18", date(2023, 5, 9)),
                ("centos", "7", date(2014, 7, 7)),
                ("centos", "8", date(2019, 9, 24)),
                ("amazonlinux", "2", date(2018, 6, 26)),
                ("amazonlinux", "2023", date(2023, 3, 15)),
                ("redhat", "8", date(2019, 5, 7)),
                ("redhat", "9", date(2022, 5, 17)),
            ]
            base_image_ids = [self.create_base_image(*img) for img in base_images]
            
            # 2. Seed packages (15 entries, multiple per base image)
            packages = []
            for base_id in base_image_ids[:6]:  # Distribute packages across base images
                packages.extend([
                    (f"openssl-{random.randint(1,3)}.{random.randint(0,1)}.{random.randint(0,20)}", base_id),
                    (f"nginx-1.{random.randint(10,25)}", base_id),
                    (f"python3.{random.randint(7,11)}", base_id),
                    (f"postgresql-{random.randint(12,15)}", base_id),
                    (f"nodejs-{random.randint(16,20)}", base_id),
                ])
            random.shuffle(packages)
            package_ids = [self.create_package(*pkg) for pkg in packages[:15]]  # Take 15
            
            # 3. Seed package_tags (15+ entries, multiple versions per package)
            tags = []
            for pkg_id in package_ids[:10]:  # Give most packages multiple tags
                tags.extend([
                    (pkg_id, f"1.{random.randint(0,2)}.{random.randint(0,20)}"),
                    (pkg_id, f"2.{random.randint(0,1)}.{random.randint(0,15)}"),
                ])
            tag_ids = [self.create_package_tag(*tag) for tag in tags]
            
            # 4. Seed vulnerabilities (15 entries)
            vulnerabilities = [
                ("CVE-2023-1234", "OpenSSL buffer overflow in TLS implementation", date(2023, 1, 15)),
                ("CVE-2022-4304", "DNS query vulnerability in Python", date(2022, 12, 4)),
                ("CVE-2023-0286", "X.509 certificate validation flaw", date(2023, 2, 7)),
                ("CVE-2022-3996", "NGINX HTTP/2 memory exhaustion", date(2022, 11, 8)),
                ("CVE-2022-3116", "PostgreSQL privilege escalation", date(2022, 10, 12)),
                ("CVE-2023-25690", "HTTP request smuggling in Node.js", date(2023, 3, 22)),
                ("CVE-2022-42010", "XML external entity vulnerability in libxml2", date(2022, 9, 30)),
                ("CVE-2023-2650", "Remote code execution in OpenSSL ASN.1", date(2023, 4, 18)),
                ("CVE-2022-37434", "Zlib buffer overflow", date(2022, 8, 5)),
                ("CVE-2023-0464", "Bypass of certificate verification", date(2023, 2, 28)),
                ("CVE-2023-0466", "Denial of service in OpenSSL", date(2023, 5, 3)),
                ("CVE-2022-4450", "Python zipfile directory traversal", date(2022, 12, 21)),
                ("CVE-2023-27522", "NGINX buffer overflow", date(2023, 4, 11)),
                ("CVE-2023-2455", "PostgreSQL memory leak", date(2023, 5, 15)),
                ("CVE-2023-23919", "Node.js HTTP header injection", date(2023, 3, 7)),
            ]
            vuln_ids = [self.create_vulnerability(*vuln) for vuln in vulnerabilities]
            
            # 5. Seed tag_vulnerabilities (associate some vulnerabilities with tags)
            severities = ["CRITICAL", "HIGH", "MEDIUM", "LOW"]
            for tag_id in tag_ids[:25]:  # Associate vulnerabilities with first 25 tags
                num_vulns = random.randint(0, 3)  # 0-3 vulnerabilities per tag
                for _ in range(num_vulns):
                    vuln_id = random.choice(vuln_ids)
                    severity = random.choice(severities)
                    self.add_vulnerability_to_tag(tag_id, vuln_id, severity)
            
            # 6. Seed commits (15+ entries)
            authors = ["Alice Smith", "Bob Johnson", "Charlie Brown", "David Wilson", "Eve Davis"]
            messages = [
                "Update security patches",
                "Fix memory leak",
                "Upgrade dependencies",
                "Address CVE vulnerability",
                "Improve performance",
                "Refactor core components",
                "Add new features",
                "Update documentation",
                "Fix regression bug",
                "Enhance logging",
            ]
            for tag_id in tag_ids[:15]:  # Add commits to first 15 tags
                for _ in range(random.randint(1, 2)):  # 1-2 commits per tag
                    commit_hash = f"{random.getrandbits(128):032x}"
                    author = random.choice(authors)
                    message = random.choice(messages)
                    if "CVE" in message and len(vuln_ids) > 0:
                        message += f" {random.choice(vuln_ids)}"
                    self.create_commit(
                        tag_id,
                        commit_hash,
                        author,
                        message
                    )
            
            print("Database seeded successfully!")
            return "Database seeded successfully!"
            
        except Exception as e:
            print(f"Error seeding database: {e}")
            return f"Error seeding database: {e}"
    
    def execute_raw_query(self, query: str):
        """
        Executes a raw SQL query and returns the results.

        :param query: The SQL query to be executed.
        :return: Query results as a list of tuples.
        """
        if not self.conn or self.conn.closed:
            self._connect()

        try:
            self.cursor.execute(query)
            if self.cursor.description:  # Ensures the query returns data (e.g., SELECT)
                return self.cursor.fetchall()
            else:
                self.conn.commit()
                return None
        except DatabaseError as e:
            print(f"Database error during query execution: {e}")
            self.conn.rollback()
            return None



# Example Usage
if __name__ == "__main__":
    # Initialize the database manager
    db_manager = DatabaseManager(
        db_name="vulnerability_db",
        user="your_username",
        password="your_password"
    )
    
    # Connect and setup the schema
    db_manager._connect()
    db_manager.setup_database()
    
    try:
        # Create sample data
        # 1. Base image
        base_id = db_manager.create_base_image("ubuntu", "20.04", date(2020, 4, 23))
        
        # 2. Package
        pkg_id = db_manager.create_package("openssl", base_id)
        
        # 3. Package tag
        tag_id = db_manager.create_package_tag(pkg_id, "1.1.1")
        
        # 4. Vulnerability
        vuln_id = db_manager.create_vulnerability(
            cve_id="CVE-2022-2068",
            description="OpenSSL vulnerability in certain ciphers",
            discovered_at=date(2022, 6, 21)
        )
        
        # 5. Associate vulnerability with tag
        db_manager.add_vulnerability_to_tag(tag_id, vuln_id, severity="HIGH")
        
        # 6. Commit
        db_manager.create_commit(
            tag_id,
            "a1b2c3d4e5f6",
            "John Doe",
            "Fixed security vulnerability in openssl"
        )
        
        # Query some data
        print("\nBase Images:")
        print(db_manager.get_base_images())
        
        print("\nPackages for base image:")
        print(db_manager.get_packages_for_base_image(base_id))
        
        print("\nVulnerabilities for tag:")
        print(db_manager.get_vulnerabilities_for_tag(tag_id))
        
    finally:
        # Clean up
        db_manager.close_connection()